import React, { useState, useRef, useEffect } from 'react';

// BACKEND_URL for sentiment analysis
const BACKEND_URL = 'https://licpodcast.onrender.com';

// Simplified themes with only essential properties
const THEMES = {
  MIDNIGHT: {
    name: 'Midnight Pulse',
    background: 'linear-gradient(135deg, #0F0F1E 0%, #1A1A3A 100%)',
    text: '#E0E0E0',
    highlight: '#7C4DFF',
    sentiments: {
      positive: 'rgba(0, 230, 118, 0.3)',
      neutral: 'rgba(255, 171, 64, 0.3)',
      negative: 'rgba(255, 82, 82, 0.3)',
      mixed: 'rgba(186, 104, 200, 0.3)'
    },
    panel: 'rgba(15, 15, 30, 0.8)',
    button: '#7C4DFF',
    buttonText: '#FFFFFF',
    buttonHover: '#9E7DFF',
    modal: 'rgba(26, 26, 58, 0.95)',
    input: '#2C2C4C',
    border: '#3F3F63',
    active: '#FFFFFF',
    inactive: 'rgba(143, 143, 158, 0.7)',
    isDark: true
  },
  EMBER: {
    name: 'Ember Glow',
    background: 'linear-gradient(135deg, #1F1F1F 0%, #2C1E1E 50%, #372222 100%)',
    text: '#F0E6E6',
    highlight: '#FF6E40',
    sentiments: {
      positive: 'rgba(102, 187, 106, 0.3)',
      neutral: 'rgba(255, 213, 79, 0.3)',
      negative: 'rgba(239, 83, 80, 0.3)',
      mixed: 'rgba(149, 117, 205, 0.3)'
    },
    panel: 'rgba(31, 31, 31, 0.85)',
    button: '#FF6E40',
    buttonText: '#1F1F1F',
    buttonHover: '#FF9E80',
    modal: 'rgba(47, 34, 34, 0.95)',
    input: '#3C2929',
    border: '#4D3636',
    active: '#F0E6E6',
    inactive: 'rgba(158, 140, 140, 0.7)',
    isDark: true
  },
  COASTAL: {
    name: 'Coastal Breeze',
    background: 'linear-gradient(135deg, #F5F7FA 0%, #E4EAF5 100%)',
    text: '#2C3E50',
    highlight: '#3498DB',
    sentiments: {
      positive: 'rgba(39, 174, 96, 0.25)',
      neutral: 'rgba(243, 156, 18, 0.25)',
      negative: 'rgba(231, 76, 60, 0.25)',
      mixed: 'rgba(142, 68, 173, 0.25)'
    },
    panel: 'rgba(245, 247, 250, 0.85)',
    button: '#3498DB',
    buttonText: '#FFFFFF',
    buttonHover: '#5DADE2',
    modal: 'rgba(228, 234, 245, 0.95)',
    input: '#FFFFFF',
    border: '#BDC3C7',
    active: '#2C3E50',
    inactive: 'rgba(149, 165, 166, 0.8)',
    isDark: false
  },
  SPRING: {
    name: 'Spring Blossom',
    background: 'linear-gradient(135deg, #FFFFFF 0%, #F9F3F9 100%)',
    text: '#4A4A4A',
    highlight: '#FF80AB',
    sentiments: {
      positive: 'rgba(76, 175, 80, 0.2)',
      neutral: 'rgba(255, 193, 7, 0.2)',
      negative: 'rgba(244, 67, 54, 0.2)',
      mixed: 'rgba(156, 39, 176, 0.2)'
    },
    panel: 'rgba(255, 255, 255, 0.9)',
    button: '#FF80AB',
    buttonText: '#FFFFFF',
    buttonHover: '#FF9EBD',
    modal: 'rgba(249, 243, 249, 0.95)',
    input: '#FFFFFF',
    border: '#E1E1E1',
    active: '#4A4A4A',
    inactive: 'rgba(158, 158, 158, 0.7)',
    isDark: false
  },
  NEUTRAL: {
    name: 'Neutral Canvas',
    background: 'linear-gradient(135deg, #F5F5F0 0%, #E8E6E1 100%)',
    text: '#3C3B37',
    highlight: '#8B7355',
    sentiments: {
      positive: 'rgba(76, 175, 80, 0.2)',
      neutral: 'rgba(255, 193, 7, 0.2)',
      negative: 'rgba(244, 67, 54, 0.2)',
      mixed: 'rgba(156, 39, 176, 0.2)'
    },
    panel: 'rgba(248, 246, 242, 0.9)',
    button: '#8B7355',
    buttonText: '#FFFFFF',
    buttonHover: '#A0845F',
    modal: 'rgba(232, 230, 225, 0.95)',
    input: '#FFFFFF',
    border: '#C4BFB6',
    active: '#3C3B37',
    inactive: 'rgba(124, 120, 112, 0.7)',
    isDark: false
  }
};

// Helper functions
const parseTime = (t) => {
  const [hh, mm, ss] = t.split(':').map(Number);
  return hh * 3600 + mm * 60 + ss;
};

const parseTranscript = (text) => {
  const lines = text.split(/\r?\n/).map(line => line.trim()).filter(Boolean);
  const entries = [];

  for (let i = 0; i < lines.length; i++) {
    const match = lines[i].match(/^\[(\d{2}:\d{2}:\d{2})\]\s+(.*)$/);
    if (match) {
      const [, time, content] = match;
      entries.push({ start: parseTime(time), text: content });
    }
  }

  for (let i = 0; i < entries.length - 1; i++) {
    entries[i].end = entries[i + 1].start;
  }
  if (entries.length > 0) {
    entries[entries.length - 1].end = entries[entries.length - 1].start + 4;
  }

  return entries;
};

const spreadWordsWithTiming = (sentences, isDarkTheme) => {
  let wordIndex = 0;
  const result = [];
  const defaultColor = isDarkTheme ? '#FFFFFF' : '#2C3E50';

  for (let i = 0; i < sentences.length; i++) {
    const sentence = sentences[i];
    const words = sentence.text.trim().split(/\s+/);
    const duration = sentence.end - sentence.start;
    const step = duration / words.length;

    result.push(...words.map((word, j) => ({
      word,
      start: sentence.start + j * step,
      end: sentence.start + (j + 1) * step,
      color: defaultColor,
      size: '24px',
      sentenceIndex: i,
      wordIndex: wordIndex++,
      animation: {
        type: 'none',
        duration: 1.2,
        delay: 0,
        intensity: 'normal'
      }
    })));
  }

  return result;
};

// Main component
export default function App() {
  // Refs
  const audioRef = useRef(null);
  const containerRef = useRef(null);
  const sentenceRefs = useRef([]);

  // Player state
  const [audioUrl, setAudioUrl] = useState(null);
  const [wordData, setWordData] = useState([]);
  const [highlightIndex, setHighlightIndex] = useState(-1);
  const [, setCurrentTime] = useState(0);
  const [mode, setMode] = useState('editor');
  const [fontFamily, setFontFamily] = useState('Arial');
  const [autoScroll, setAutoScroll] = useState(true);

  // Theme state
  const [currentTheme, setCurrentTheme] = useState(THEMES.MIDNIGHT);

  // Sentiment analysis states
  const [sentimentData, setSentimentData] = useState({});
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [editingSentimentIndex, setEditingSentimentIndex] = useState(null);
  const [analysisError, setAnalysisError] = useState(null);
  const [serverWarmingUp, setServerWarmingUp] = useState(true);

  // Word editing state
  const [editingWordIndex, setEditingWordIndex] = useState(null);
  const [editedWordText, setEditedWordText] = useState('');

  // Animation editing state
  const [animationEditorOpen, setAnimationEditorOpen] = useState(false);
  const [editingWordAnimation, setEditingWordAnimation] = useState(null);
  const [tempAnimation, setTempAnimation] = useState({
    type: 'none',
    duration: 1.2,
    delay: 0,
    intensity: 'normal'
  });

  // Global animation effects
  const [globalAnimations, setGlobalAnimations] = useState({
    sentimentBackground: false
  });

  // Sentiment background tracking
  const [sentimentScore, setSentimentScore] = useState(0); // Target cumulative score
  const [displaySentimentScore, setDisplaySentimentScore] = useState(0); // Smoothly animated score
  const [sentimentIntensity, setSentimentIntensity] = useState(0.5); // How much it affects background (0-1) - default 50%

  // Audio analysis state
  const [audioContext, setAudioContext] = useState(null);
  const [analyser, setAnalyser] = useState(null);
  const [, setAudioData] = useState({
    volume: 0,
    frequency: new Array(8).fill(0),
    dominantFreq: 0
  });

  // Group words by sentence
  const groupedBySentence = wordData.reduce((acc, word) => {
    if (!acc[word.sentenceIndex]) acc[word.sentenceIndex] = [];
    acc[word.sentenceIndex].push(word);
    return acc;
  }, []);

  // Load saved theme from localStorage on initial render
  useEffect(() => {
    try {
      const savedThemeName = localStorage.getItem('selectedTheme');
      if (savedThemeName) {
        const theme = Object.values(THEMES).find(t => t.name === savedThemeName);
        if (theme) setCurrentTheme(theme);
      }
    } catch (error) {
      console.warn("Couldn't access localStorage. Using default theme.", error);
    }
  }, []);

  // Warm up the server on app startup
  useEffect(() => {
    const warmUpServer = async () => {
      try {
        console.log('Warming up server...');
        const response = await fetch(`${BACKEND_URL}/`, {
          method: 'GET',
          signal: AbortSignal.timeout(30000) // 30 second timeout
        });
        
        if (response.ok) {
          console.log('Server is ready!');
        } else {
          console.log('Server responded but may still be warming up');
        }
      } catch (error) {
        console.log('Server warming up (this is normal on first load):', error.message);
      } finally {
        setServerWarmingUp(false);
      }
    };

    warmUpServer();
  }, []);

  // Save theme preference when it changes
  useEffect(() => {
    try {
      localStorage.setItem('selectedTheme', currentTheme.name);

      // Update word colors based on theme change
      if (wordData.length > 0) {
        const wordColor = currentTheme.isDark ? '#FFFFFF' : '#2C3E50';

        setWordData(prev => prev.map(word => ({
          ...word,
          color: wordColor
        })));
      }
    } catch (error) {
      console.warn("Couldn't access localStorage. Theme preference won't be saved.", error);
    }
  }, [currentTheme, wordData.length]);

  // Reset sentiment tracking when sentiment background is enabled
  useEffect(() => {
    if (globalAnimations.sentimentBackground) {
      setSentimentScore(0);
      setDisplaySentimentScore(0);
      console.log('Sentiment background enabled - resetting score to 0');
    }
  }, [globalAnimations.sentimentBackground]);

  // Smooth animation between sentiment score changes
  useEffect(() => {
    if (!globalAnimations.sentimentBackground) return;
    
    const animationDuration = 3000; // 3 seconds for smooth transition
    const startTime = Date.now();
    const startScore = displaySentimentScore;
    const targetScore = sentimentScore;
    const scoreDiff = targetScore - startScore;
    
    if (Math.abs(scoreDiff) < 0.01) return; // Skip if no meaningful change
    
    const animate = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / animationDuration, 1);
      
      // Use easeInOutCubic for smooth animation
      const easeProgress = progress < 0.5 
        ? 4 * progress * progress * progress
        : 1 - Math.pow(-2 * progress + 2, 3) / 2;
      
      const currentScore = startScore + (scoreDiff * easeProgress);
      setDisplaySentimentScore(currentScore);
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        setDisplaySentimentScore(targetScore); // Ensure we end exactly at target
      }
    };
    
    requestAnimationFrame(animate);
  }, [sentimentScore, globalAnimations.sentimentBackground]);

  // Create and inject animation styles
  useEffect(() => {
    const style = document.createElement('style');
    style.textContent = `
      @keyframes spin { to { transform: rotate(360deg); } }
      @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
      @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
      
      /* Word Animation Keyframes */
      @keyframes wordFadeIn { 
        from { opacity: 0; } 
        to { opacity: 1; } 
      }
      @keyframes wordBounce { 
        0%, 20%, 53%, 80%, 100% { transform: translate3d(0,0,0); } 
        40%, 43% { transform: translate3d(0,-8px,0); } 
        70% { transform: translate3d(0,-4px,0); } 
      }
      @keyframes wordPulse { 
        0% { transform: scale(1); } 
        50% { transform: scale(1.1); } 
        100% { transform: scale(1); } 
      }
      @keyframes wordGlow { 
        0%, 100% { text-shadow: 0 0 5px currentColor; } 
        50% { text-shadow: 0 0 20px currentColor, 0 0 30px currentColor; } 
      }
      @keyframes wordSlideUp { 
        from { transform: translateY(20px); opacity: 0; } 
        to { transform: translateY(0); opacity: 1; } 
      }
      @keyframes wordTypewriter { 
        from { width: 0; } 
        to { width: 100%; } 
      }
      @keyframes wordShake { 
        0%, 100% { transform: translateX(0); } 
        10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); } 
        20%, 40%, 60%, 80% { transform: translateX(2px); } 
      }
      
      /* Emotional Animation Keyframes */
      @keyframes wordJoy { 
        0% { transform: translateY(0) scale(1); filter: brightness(1); }
        25% { transform: translateY(-8px) scale(1.05); filter: brightness(1.2) saturate(1.3); }
        50% { transform: translateY(-4px) scale(1.02); filter: brightness(1.1) saturate(1.2); }
        75% { transform: translateY(-2px) scale(1.01); filter: brightness(1.05) saturate(1.1); }
        100% { transform: translateY(0) scale(1); filter: brightness(1); }
      }
      @keyframes wordHope { 
        0% { transform: translateY(0) scale(1); opacity: 0.8; text-shadow: 0 0 5px rgba(255, 223, 0, 0.3); }
        50% { transform: translateY(-3px) scale(1.02); opacity: 1; text-shadow: 0 0 15px rgba(255, 223, 0, 0.6); }
        100% { transform: translateY(-1px) scale(1); opacity: 1; text-shadow: 0 0 10px rgba(255, 223, 0, 0.4); }
      }
      @keyframes wordRelief { 
        0% { transform: scale(1.1); opacity: 0.9; }
        25% { transform: scale(1.05); opacity: 0.95; }
        50% { transform: scale(1.02); opacity: 1; }
        75% { transform: scale(1.01); opacity: 1; }
        100% { transform: scale(1); opacity: 1; }
      }
      @keyframes wordSadness { 
        0% { transform: translateY(0) scale(1); opacity: 1; filter: saturate(0.7); }
        50% { transform: translateY(2px) scale(0.98); opacity: 0.8; filter: saturate(0.5); }
        100% { transform: translateY(1px) scale(0.99); opacity: 0.9; filter: saturate(0.6); }
      }
      @keyframes wordFear { 
        0%, 100% { transform: translateX(0) scale(1); }
        10% { transform: translateX(-1px) scale(0.99); }
        20% { transform: translateX(1px) scale(0.98); }
        30% { transform: translateX(-0.5px) scale(0.99); }
        40% { transform: translateX(0.5px) scale(1); }
        50% { transform: translateX(-1px) scale(0.98); }
        60% { transform: translateX(1px) scale(0.99); }
        70% { transform: translateX(-0.5px) scale(1); }
        80% { transform: translateX(0.5px) scale(0.99); }
        90% { transform: translateX(-0.5px) scale(1); }
      }
      @keyframes wordAnger { 
        0%, 100% { transform: translateX(0) scale(1); filter: hue-rotate(0deg); }
        10% { transform: translateX(-3px) scale(1.02); filter: hue-rotate(10deg); }
        20% { transform: translateX(3px) scale(1.02); filter: hue-rotate(-10deg); }
        30% { transform: translateX(-2px) scale(1.01); filter: hue-rotate(5deg); }
        40% { transform: translateX(2px) scale(1.01); filter: hue-rotate(-5deg); }
        50% { transform: translateX(-1px) scale(1); filter: hue-rotate(0deg); }
      }
      @keyframes wordSurprise { 
        0% { transform: scale(1) rotate(0deg); }
        25% { transform: scale(1.15) rotate(2deg); }
        50% { transform: scale(1.1) rotate(-1deg); }
        75% { transform: scale(1.05) rotate(1deg); }
        100% { transform: scale(1) rotate(0deg); }
      }
      @keyframes wordComfort { 
        0% { transform: scale(1); text-shadow: 0 0 5px rgba(255, 182, 193, 0.4); }
        50% { transform: scale(1.02); text-shadow: 0 0 15px rgba(255, 182, 193, 0.7); }
        100% { transform: scale(1); text-shadow: 0 0 10px rgba(255, 182, 193, 0.5); }
      }
      @keyframes wordStrength { 
        0% { transform: scale(1); font-weight: normal; }
        25% { transform: scale(1.05); font-weight: bold; }
        50% { transform: scale(1.03); font-weight: bolder; }
        75% { transform: scale(1.01); font-weight: bold; }
        100% { transform: scale(1); font-weight: normal; }
      }
      @keyframes wordVulnerability { 
        0% { transform: scale(0.9); opacity: 0.7; }
        50% { transform: scale(0.95); opacity: 0.85; }
        100% { transform: scale(1); opacity: 1; }
      }
      
      /* Animation Classes */
      .word-animate-fadeIn { animation: wordFadeIn var(--duration, 1.2s) ease-out var(--delay, 0s) both; }
      .word-animate-bounce { animation: wordBounce var(--duration, 1.2s) ease-out var(--delay, 0s) both; }
      .word-animate-pulse { animation: wordPulse var(--duration, 1.2s) ease-out var(--delay, 0s) both; }
      .word-animate-glow { animation: wordGlow var(--duration, 1.2s) ease-out var(--delay, 0s) both; }
      .word-animate-slideUp { animation: wordSlideUp var(--duration, 1.2s) ease-out var(--delay, 0s) both; }
      .word-animate-typewriter { 
        animation: wordTypewriter var(--duration, 1.2s) steps(20) var(--delay, 0s) both;
        overflow: hidden;
        white-space: nowrap;
        display: inline-block;
      }
      .word-animate-shake { animation: wordShake var(--duration, 1.2s) ease-out var(--delay, 0s) both; }
      
      /* Emotional Animation Classes */
      .word-animate-joy { animation: wordJoy var(--duration, 1.2s) ease-out var(--delay, 0s) both; }
      .word-animate-hope { animation: wordHope var(--duration, 1.2s) ease-out var(--delay, 0s) both; }
      .word-animate-relief { animation: wordRelief var(--duration, 1.2s) ease-out var(--delay, 0s) both; }
      .word-animate-sadness { animation: wordSadness var(--duration, 1.2s) ease-out var(--delay, 0s) both; }
      .word-animate-fear { animation: wordFear var(--duration, 1.2s) ease-out var(--delay, 0s) both; }
      .word-animate-anger { animation: wordAnger var(--duration, 1.2s) ease-out var(--delay, 0s) both; }
      .word-animate-surprise { animation: wordSurprise var(--duration, 1.2s) ease-out var(--delay, 0s) both; }
      .word-animate-comfort { animation: wordComfort var(--duration, 1.2s) ease-out var(--delay, 0s) both; }
      .word-animate-strength { animation: wordStrength var(--duration, 1.2s) ease-out var(--delay, 0s) both; }
      .word-animate-vulnerability { animation: wordVulnerability var(--duration, 1.2s) ease-out var(--delay, 0s) both; }
      
      /* Preview animation trigger */
      .word-preview-animation {
        animation-play-state: running !important;
      }
      
      /* Positive sentiment background pulse animation */
      @keyframes positiveBackgroundPulse {
        0%, 100% { filter: brightness(1); }
        50% { filter: brightness(1.02); }
      }
      
      .positive-sentiment-background {
        animation: positiveBackgroundPulse 4s ease-in-out infinite;
      }
    `;
    document.head.appendChild(style);
    return () => document.head.removeChild(style);
  }, []);

  // Word and audio time tracking
  useEffect(() => {
    const interval = setInterval(() => {
      const time = audioRef.current?.currentTime;
      if (time == null || wordData.length === 0) return;

      setCurrentTime(time);
      const index = wordData.findIndex(w => time >= w.start && time < w.end);
      setHighlightIndex(index);

      // Update sentiment score based on current sentence (cumulative approach)
      if (index !== -1 && globalAnimations.sentimentBackground && Object.keys(sentimentData).length > 0) {
        const currentWord = wordData[index];
        const sentenceIndex = currentWord.sentenceIndex;
        
        // Calculate cumulative score from sentence 0 up to current sentence
        let cumulativeScore = 0;
        for (let i = 0; i <= sentenceIndex; i++) {
          const sentimentInfo = sentimentData[i];
          if (sentimentInfo && sentimentInfo.sentiment) {
            if (sentimentInfo.sentiment === 'positive') {
              cumulativeScore += 1;
            } else if (sentimentInfo.sentiment === 'negative') {
              cumulativeScore -= 1;
            }
            // Neutral and mixed don't change the score
          }
        }
        
        // Update score if it changed
        setSentimentScore(prev => {
          if (prev !== cumulativeScore) {
            console.log('Updating cumulative sentiment score:', { 
              sentenceIndex, 
              oldScore: prev, 
              newScore: cumulativeScore 
            });
            return cumulativeScore;
          }
          return prev;
        });
      }

      if (index !== -1 && autoScroll) {
        const sentenceIndex = wordData[index].sentenceIndex;
        const el = sentenceRefs.current[sentenceIndex];
        if (el && containerRef.current) {
          const containerRect = containerRef.current.getBoundingClientRect();
          const elRect = el.getBoundingClientRect();
          const isInView = (elRect.top >= containerRect.top && elRect.bottom <= containerRect.bottom);
          if (!isInView) {
            el.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }
      }
    }, 50);

    return () => clearInterval(interval);
  }, [wordData, autoScroll, globalAnimations.sentimentBackground, sentimentData]);

  // Start audio analysis when audio starts playing
  useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;

    const handlePlay = () => {
      // Audio analysis no longer needed for sentiment background
      console.log('Audio playing, sentiment tracking enabled:', globalAnimations.sentimentBackground);
    };

    const handlePause = () => {
      if (audioContext && audioContext.state !== 'closed') {
        audioContext.suspend();
      }
    };

    const handleResume = () => {
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume();
      }
    };

    audio.addEventListener('play', handlePlay);
    audio.addEventListener('pause', handlePause);
    audio.addEventListener('play', handleResume);

    return () => {
      audio.removeEventListener('play', handlePlay);
      audio.removeEventListener('pause', handlePause);
      audio.removeEventListener('play', handleResume);
    };
  }, [audioRef.current, globalAnimations, audioContext]);

  // Audio analysis loop
  useEffect(() => {
    if (!analyser || !audioContext) return;

    let animationFrame;
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    const analyze = () => {
      if (audioContext.state !== 'running') return;

      analyser.getByteFrequencyData(dataArray);
      
      // Calculate volume (RMS)
      let sum = 0;
      for (let i = 0; i < bufferLength; i++) {
        sum += dataArray[i] * dataArray[i];
      }
      const volume = Math.sqrt(sum / bufferLength) / 255;

      // Get frequency data (simplified to 8 bands)
      const frequencyBands = [];
      const bandSize = Math.floor(bufferLength / 8);
      for (let i = 0; i < 8; i++) {
        let bandSum = 0;
        for (let j = i * bandSize; j < (i + 1) * bandSize; j++) {
          bandSum += dataArray[j];
        }
        frequencyBands.push(bandSum / bandSize / 255);
      }

      // Find dominant frequency
      const maxIndex = dataArray.indexOf(Math.max(...dataArray));
      const dominantFreq = (maxIndex / bufferLength) * (audioContext.sampleRate / 2);

      setAudioData({
        volume: volume,
        frequency: frequencyBands,
        dominantFreq: dominantFreq
      });

      // Debug logging (remove this later)
      if (Math.random() < 0.01) { // Log 1% of the time to avoid spam
        console.log('Audio data:', { volume, frequencyBands, dominantFreq });
      }

      animationFrame = requestAnimationFrame(analyze);
    };

    analyze();

    return () => {
      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
      }
    };
  }, [analyser, audioContext]);

  // Cleanup audio context on unmount
  useEffect(() => {
    return () => {
      if (audioContext && audioContext.state !== 'closed') {
        audioContext.close();
      }
    };
  }, [audioContext]);

  // File handling functions
  const handleAudioUpload = (e) => {
    const file = e.target.files[0];
    if (file) {
      setAudioUrl(URL.createObjectURL(file));
      // Reset audio context when new audio is loaded
      if (audioContext) {
        audioContext.close();
        setAudioContext(null);
        setAnalyser(null);
      }
    }
  };

  // Audio analysis setup (currently unused)
  const _setupAudioAnalysis = async () => {
    if (!audioRef.current || audioContext) return;

    try {
      console.log('Setting up audio analysis...');
      const context = new (window.AudioContext || window.webkitAudioContext)();
      const source = context.createMediaElementSource(audioRef.current);
      const analyzer = context.createAnalyser();
      
      analyzer.fftSize = 128; // Small for performance
      analyzer.smoothingTimeConstant = 0.8;
      
      source.connect(analyzer);
      analyzer.connect(context.destination);
      
      setAudioContext(context);
      setAnalyser(analyzer);
      
      console.log('Audio analysis setup complete', { context, analyzer });
    } catch (error) {
      console.error('Error setting up audio analysis:', error);
    }
  };

  const handleTranscriptUpload = async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const text = await file.text();
    const parsed = parseTranscript(text);
    const wordList = spreadWordsWithTiming(parsed, currentTheme.isDark);

    setWordData(wordList);
    setSentimentData({});
  };

  // Word editing functions
  const updateWord = (index, changes) => {
    setWordData(prev => {
      const copy = [...prev];
      copy[index] = { ...copy[index], ...changes };
      return copy;
    });
  };

  const handleWordEditSubmit = (e) => {
    e.preventDefault();
    if (editingWordIndex !== null && editedWordText.trim()) {
      updateWord(editingWordIndex, { word: editedWordText.trim() });
      setEditingWordIndex(null);
      setEditedWordText('');
    }
  };

  // Sentiment analysis functions
  const analyzeSentiment = async () => {
    if (wordData.length === 0) return;

    setIsAnalyzing(true);
    setAnalysisError(null);

    try {
      const sentences = Object.values(groupedBySentence).map(words => ({
        sentenceIndex: words[0].sentenceIndex,
        text: words.map(w => w.word).join(' ')
      }));

      const response = await fetch(`${BACKEND_URL}/api/analyze-sentiment`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ sentences })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`Server responded with status: ${response.status}. ${errorData.error || ''}`);
      }

      const data = await response.json();

      // Process results
      const sentimentMap = {};
      data.documents.forEach(doc => {
        const sentenceIndex = parseInt(doc.id);
        sentimentMap[sentenceIndex] = {
          sentiment: doc.sentiment,
          scores: doc.confidenceScores
        };
      });

      setSentimentData(sentimentMap);
    } catch (error) {
      console.error('Error analyzing sentiment:', error);
      setAnalysisError(error.message || 'Failed to analyze sentiment');
    } finally {
      setIsAnalyzing(false);
    }
  };

  const getSentimentColor = (sentenceIndex) => {
    if (!sentimentData[sentenceIndex]) return 'transparent';
    const sentiment = sentimentData[sentenceIndex].sentiment;
    return currentTheme.sentiments[sentiment] || 'transparent';
  };

  const getSentimentEmoji = (sentiment) => {
    const emojis = { positive: '😊', neutral: '😐', negative: '😞', mixed: '😕' };
    return emojis[sentiment] || '';
  };

  const updateSentiment = (sentenceIndex, sentiment) => {
    setSentimentData(prev => ({
      ...prev,
      [sentenceIndex]: {
        sentiment,
        scores: {
          positive: sentiment === 'positive' ? 1 : 0,
          neutral: sentiment === 'neutral' ? 1 : 0,
          negative: sentiment === 'negative' ? 1 : 0,
          mixed: sentiment === 'mixed' ? 1 : 0
        }
      }
    }));
    setEditingSentimentIndex(null);
  };

  // Animation editing functions
  const openAnimationEditor = (wordIndex) => {
    const word = wordData[wordIndex];
    if (word) {
      setEditingWordAnimation(wordIndex);
      setTempAnimation({ ...word.animation });
      setAnimationEditorOpen(true);
    }
  };

  const saveAnimation = () => {
    if (editingWordAnimation !== null) {
      updateWord(editingWordAnimation, { animation: { ...tempAnimation } });
      setAnimationEditorOpen(false);
      setEditingWordAnimation(null);
    }
  };

  const cancelAnimationEdit = () => {
    setAnimationEditorOpen(false);
    setEditingWordAnimation(null);
    setTempAnimation({
      type: 'none',
      duration: 1.2,
      delay: 0,
      intensity: 'normal'
    });
  };

  const previewAnimation = () => {
    if (editingWordAnimation === null || tempAnimation.type === 'none') return;
    
    // Find the word element in the editor and trigger animation
    const wordElements = document.querySelectorAll(`[data-word-index="${editingWordAnimation}"]`);
    wordElements.forEach(element => {
      // Remove any existing animation classes
      element.className = element.className.replace(/word-animate-\w+/g, '');
      
      // Set CSS custom properties for duration and delay
      element.style.setProperty('--duration', `${tempAnimation.duration}s`);
      element.style.setProperty('--delay', `${tempAnimation.delay}s`);
      
      // Add the animation class
      const animationClass = `word-animate-${tempAnimation.type}`;
      element.classList.add(animationClass);
      
      // Remove the animation class after it completes to allow re-triggering
      const totalDuration = (tempAnimation.duration + tempAnimation.delay) * 1000;
      setTimeout(() => {
        element.classList.remove(animationClass);
      }, totalDuration);
    });
  };

  // UI Components
  const ThemeSwitcher = () => (
    <div style={{
      display: 'flex',
      flexWrap: 'wrap',
      gap: '8px',
      justifyContent: 'center',
      marginTop: '10px',
      padding: '10px',
      borderRadius: '8px',
      background: currentTheme.panel
    }}>
      {Object.values(THEMES).map(theme => (
        <button
          key={theme.name}
          onClick={() => setCurrentTheme(theme)}
          style={{
            padding: '8px 12px',
            background: theme.button,
            color: theme.buttonText,
            border: theme.name === currentTheme.name ? `2px solid ${theme.text}` : 'none',
            borderRadius: '4px',
            cursor: 'pointer',
            fontWeight: theme.name === currentTheme.name ? 'bold' : 'normal'
          }}
        >
          {theme.name}
        </button>
      ))}
    </div>
  );

  const renderHeader = () => (
    <div style={{ position: 'fixed', top: '10px', right: '10px', zIndex: 100 }}>
      <button
        onClick={() => setMode(mode === 'editor' ? 'player' : 'editor')}
        style={{
          padding: '8px 16px',
          borderRadius: '8px',
          border: 'none',
          background: currentTheme.button,
          color: currentTheme.buttonText,
          cursor: 'pointer',
          boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
          transition: 'all 0.2s ease'
        }}
        onMouseEnter={(e) => {
          e.currentTarget.style.background = currentTheme.buttonHover;
          e.currentTarget.style.transform = 'translateY(-2px)';
        }}
        onMouseLeave={(e) => {
          e.currentTarget.style.background = currentTheme.button;
          e.currentTarget.style.transform = 'translateY(0)';
        }}
      >
        {mode === 'editor' ? 'Switch to Player View' : 'Back to Editor'}
      </button>
    </div>
  );

  const renderEditorControls = () => (
    <div style={{
      display: 'flex',
      flexWrap: 'wrap',
      gap: '15px',
      justifyContent: 'center',
      alignItems: 'center',
      padding: '15px',
      borderRadius: '8px',
      background: currentTheme.panel,
      boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
      marginTop: '15px',
      animation: 'fadeIn 0.5s ease'
    }}>
      <label style={{
        display: 'flex',
        alignItems: 'center',
        color: currentTheme.text,
        background: currentTheme.input,
        padding: '6px 10px',
        borderRadius: '4px',
        border: `1px solid ${currentTheme.border}`
      }}>
        Font:
        <select
          value={fontFamily}
          onChange={(e) => setFontFamily(e.target.value)}
          style={{
            marginLeft: '5px',
            padding: '2px 5px',
            background: currentTheme.input,
            color: currentTheme.text,
            border: `1px solid ${currentTheme.border}`,
            borderRadius: '4px'
          }}
        >
          <option value="sans-serif">Sans-serif</option>
          <option value="serif">Serif</option>
          <option value="monospace">Monospace</option>
          <option value="Georgia">Georgia</option>
          <option value="Arial">Arial</option>
          <option value="Courier New">Courier New</option>
          <option value="Times New Roman">Times New Roman</option>
        </select>
      </label>

      <label style={{
        display: 'flex',
        alignItems: 'center',
        color: currentTheme.text,
        background: currentTheme.input,
        padding: '6px 10px',
        borderRadius: '4px',
        border: `1px solid ${currentTheme.border}`
      }}>
        <input
          type="checkbox"
          checked={autoScroll}
          onChange={(e) => setAutoScroll(e.target.checked)}
          style={{ marginRight: '5px' }}
        />
        Auto Scroll (keeps current sentence visible)
      </label>

      {/* Global Animation Effects */}
      <div style={{
        display: 'flex',
        flexDirection: 'column',
        gap: '8px',
        padding: '10px',
        background: currentTheme.input,
        border: `1px solid ${currentTheme.border}`,
        borderRadius: '6px'
      }}>
        <label style={{ color: currentTheme.text, fontWeight: 'bold', fontSize: '14px' }}>
          Sentiment Effects
        </label>
        
        <label style={{
          display: 'flex',
          alignItems: 'center',
          color: currentTheme.text,
          fontSize: '13px'
        }}>
          <input
            type="checkbox"
            checked={globalAnimations.sentimentBackground}
            onChange={(e) => setGlobalAnimations(prev => ({ ...prev, sentimentBackground: e.target.checked }))}
            style={{ marginRight: '8px' }}
          />
          🌈 Sentiment Background (background changes with emotional tone)
        </label>

        {globalAnimations.sentimentBackground && (
          <div style={{ 
            fontSize: '12px', 
            opacity: 0.8, 
            color: currentTheme.text,
            padding: '8px',
            background: currentTheme.modal,
            borderRadius: '4px',
            marginTop: '8px'
          }}>
            <div>Current Score: <strong>{displaySentimentScore.toFixed(1)}</strong> (Target: {sentimentScore.toFixed(1)})</div>
            <div style={{ fontSize: '11px', marginTop: '4px' }}>
              Debug: Highlighted word #{highlightIndex}, Sentence #{wordData[highlightIndex]?.sentenceIndex}
            </div>
            
            <div style={{ marginTop: '8px' }}>
              <label style={{ color: currentTheme.text, display: 'block', marginBottom: '5px', fontSize: '11px' }}>
                Effect Intensity: {(sentimentIntensity * 100).toFixed(0)}%
              </label>
              <input
                type="range"
                min="0.1"
                max="1.0"
                step="0.1"
                value={sentimentIntensity}
                onChange={(e) => setSentimentIntensity(parseFloat(e.target.value))}
                style={{ width: '100%' }}
              />
            </div>
            
            <div style={{ fontSize: '11px', marginTop: '4px' }}>
              Positive moments brighten • Negative moments darken
            </div>
          </div>
        )}
      </div>

      {/* Server Status Indicator */}
      {serverWarmingUp && (
        <div style={{
          display: 'flex',
          alignItems: 'center',
          gap: '8px',
          padding: '8px 12px',
          background: currentTheme.input,
          border: `1px solid ${currentTheme.border}`,
          borderRadius: '6px',
          color: currentTheme.text,
          fontSize: '14px'
        }}>
          <span className="spinner" style={{
            display: 'inline-block',
            width: '12px',
            height: '12px',
            border: `2px solid ${currentTheme.text}40`,
            borderRadius: '50%',
            borderTopColor: currentTheme.text,
            animation: 'spin 1s linear infinite'
          }}></span>
          Warming up server...
        </div>
      )}

      {/* Sentiment Analysis Button */}
      {wordData.length > 0 && (
        <button
          onClick={analyzeSentiment}
          disabled={isAnalyzing}
          style={{
            padding: '8px 16px',
            borderRadius: '8px',
            background: isAnalyzing ? `${currentTheme.button}80` : currentTheme.button,
            color: currentTheme.buttonText,
            border: 'none',
            cursor: isAnalyzing ? 'not-allowed' : 'pointer',
            display: 'flex',
            alignItems: 'center',
            gap: '5px',
            boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
            transition: 'all 0.2s ease'
          }}
          onMouseEnter={(e) => {
            if (!isAnalyzing) {
              e.currentTarget.style.background = currentTheme.buttonHover;
              e.currentTarget.style.transform = 'translateY(-2px)';
            }
          }}
          onMouseLeave={(e) => {
            e.currentTarget.style.background = isAnalyzing ? `${currentTheme.button}80` : currentTheme.button;
            e.currentTarget.style.transform = 'translateY(0)';
          }}
        >
          {isAnalyzing ? (
            <>
              <span className="spinner" style={{
                display: 'inline-block',
                width: '12px',
                height: '12px',
                border: `2px solid ${currentTheme.buttonText}40`,
                borderRadius: '50%',
                borderTopColor: currentTheme.buttonText,
                animation: 'spin 1s linear infinite'
              }}></span>
              Analyzing...
            </>
          ) : (
            'Analyze Sentiment'
          )}
        </button>
      )}
    </div>
  );

  // Modals
  const renderSentimentEditingModal = () => {
    if (editingSentimentIndex === null) return null;

    return (
      <div style={{
        position: 'fixed',
        top: 0, left: 0, right: 0, bottom: 0,
        background: 'rgba(0, 0, 0, 0.7)',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        zIndex: 1000,
        animation: 'fadeIn 0.3s ease'
      }}>
        <div style={{
          background: currentTheme.modal,
          padding: '20px',
          borderRadius: '12px',
          width: '90%',
          maxWidth: '400px',
          boxShadow: '0 10px 25px rgba(0,0,0,0.2)'
        }}>
          <h3 style={{ marginTop: 0, color: currentTheme.text }}>Edit Sentiment</h3>

          <p style={{ color: currentTheme.text, marginBottom: '20px' }}>
            {groupedBySentence[editingSentimentIndex]?.map(w => w.word).join(' ')}
          </p>

          <div style={{
            display: 'flex',
            flexWrap: 'wrap',
            gap: '10px',
            justifyContent: 'center'
          }}>
            {['positive', 'neutral', 'negative', 'mixed'].map(sentiment => (
              <button
                key={sentiment}
                onClick={() => updateSentiment(editingSentimentIndex, sentiment)}
                style={{
                  padding: '10px 15px',
                  background: currentTheme.sentiments[sentiment],
                  border: `2px solid ${currentTheme.highlight}`,
                  borderRadius: '8px',
                  cursor: 'pointer',
                  display: 'flex',
                  alignItems: 'center',
                  gap: '5px',
                  color: currentTheme.text,
                  fontWeight: 'bold',
                  transition: 'transform 0.2s ease'
                }}
                onMouseEnter={e => e.currentTarget.style.transform = 'scale(1.05)'}
                onMouseLeave={e => e.currentTarget.style.transform = 'scale(1)'}
              >
                {getSentimentEmoji(sentiment)} {sentiment.charAt(0).toUpperCase() + sentiment.slice(1)}
              </button>
            ))}
          </div>

          <div style={{ marginTop: '20px', textAlign: 'center' }}>
            <button
              onClick={() => setEditingSentimentIndex(null)}
              style={{
                padding: '8px 16px',
                background: currentTheme.button,
                color: currentTheme.buttonText,
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
                transition: 'background 0.2s ease'
              }}
              onMouseEnter={e => e.currentTarget.style.background = currentTheme.buttonHover}
              onMouseLeave={e => e.currentTarget.style.background = currentTheme.button}
            >
              Cancel
            </button>
          </div>
        </div>
      </div>
    );
  };

  const renderWordEditingModal = () => {
    if (editingWordIndex === null) return null;

    const wordToEdit = wordData[editingWordIndex];
    if (!wordToEdit) return null;

    return (
      <div style={{
        position: 'fixed',
        top: 0, left: 0, right: 0, bottom: 0,
        background: 'rgba(0, 0, 0, 0.7)',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        zIndex: 1000,
        animation: 'fadeIn 0.3s ease'
      }}>
        <div style={{
          background: currentTheme.modal,
          padding: '20px',
          borderRadius: '12px',
          width: '90%',
          maxWidth: '400px',
          boxShadow: '0 10px 25px rgba(0,0,0,0.2)'
        }}>
          <h3 style={{ marginTop: 0, color: currentTheme.text }}>Edit Word</h3>

          <form onSubmit={handleWordEditSubmit}>
            <input
              type="text"
              value={editedWordText}
              onChange={e => setEditedWordText(e.target.value)}
              placeholder={wordToEdit.word}
              autoFocus
              style={{
                width: '100%',
                padding: '10px',
                borderRadius: '4px',
                border: `1px solid ${currentTheme.border}`,
                background: currentTheme.input,
                color: currentTheme.text,
                fontSize: '16px',
                marginBottom: '15px'
              }}
            />

            <div style={{ display: 'flex', justifyContent: 'space-between', gap: '10px' }}>
              <button
                type="button"
                onClick={() => {
                  setEditingWordIndex(null);
                  setEditedWordText('');
                }}
                style={{
                  padding: '8px 16px',
                  background: 'transparent',
                  color: currentTheme.text,
                  border: `1px solid ${currentTheme.border}`,
                  borderRadius: '4px',
                  cursor: 'pointer',
                  flexGrow: 1,
                  transition: 'background 0.2s ease'
                }}
                onMouseEnter={e => e.currentTarget.style.background = 'rgba(255,255,255,0.1)'}
                onMouseLeave={e => e.currentTarget.style.background = 'transparent'}
              >
                Cancel
              </button>

              <button
                type="submit"
                style={{
                  padding: '8px 16px',
                  background: currentTheme.button,
                  color: currentTheme.buttonText,
                  border: 'none',
                  borderRadius: '4px',
                  cursor: 'pointer',
                  flexGrow: 1,
                  transition: 'background 0.2s ease'
                }}
                onMouseEnter={e => e.currentTarget.style.background = currentTheme.buttonHover}
                onMouseLeave={e => e.currentTarget.style.background = currentTheme.button}
              >
                Save
              </button>
            </div>
          </form>
        </div>
      </div>
    );
  };

  const renderAnimationEditorModal = () => {
    if (!animationEditorOpen || editingWordAnimation === null) return null;

    const wordToAnimate = wordData[editingWordAnimation];
    if (!wordToAnimate) return null;

    const animationTypes = [
      { 
        category: 'Basic',
        options: [
          { value: 'none', label: 'None', description: 'No animation' },
          { value: 'fadeIn', label: 'Fade In', description: 'Gradually appears' },
          { value: 'bounce', label: 'Bounce', description: 'Bounces into view' },
          { value: 'pulse', label: 'Pulse', description: 'Gentle pulsing effect' },
          { value: 'glow', label: 'Glow', description: 'Glowing text effect' },
          { value: 'slideUp', label: 'Slide Up', description: 'Slides up from below' },
          { value: 'typewriter', label: 'Typewriter', description: 'Types out letter by letter' },
          { value: 'shake', label: 'Shake', description: 'Shaking emphasis' }
        ]
      },
      {
        category: 'Emotional',
        options: [
          { value: 'joy', label: '😊 Joy', description: 'Upward bounce with warm glow' },
          { value: 'hope', label: '🌅 Hope', description: 'Gentle glow with upward float' },
          { value: 'relief', label: '😌 Relief', description: 'Relaxing breath-like animation' },
          { value: 'sadness', label: '😢 Sadness', description: 'Gentle downward drift with fade' },
          { value: 'fear', label: '😰 Fear', description: 'Trembling with anxiety' },
          { value: 'anger', label: '😠 Anger', description: 'Sharp shaking with intensity' },
          { value: 'surprise', label: '😲 Surprise', description: 'Quick scale-up with rotation' },
          { value: 'comfort', label: '🤗 Comfort', description: 'Warm, embracing glow' },
          { value: 'strength', label: '💪 Strength', description: 'Bold, confident pulse' },
          { value: 'vulnerability', label: '🥺 Vulnerability', description: 'Soft, hesitant appearance' }
        ]
      }
    ];

    return (
      <div style={{
        position: 'fixed',
        top: 0, left: 0, right: 0, bottom: 0,
        background: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        justifyContent: 'flex-end',
        alignItems: 'stretch',
        zIndex: 1000,
        animation: 'fadeIn 0.3s ease'
      }}>
        <div style={{
          background: currentTheme.modal,
          padding: '25px',
          width: '400px',
          maxWidth: '40vw',
          boxShadow: '-5px 0 25px rgba(0,0,0,0.3)',
          overflowY: 'auto',
          borderTopLeftRadius: '12px',
          borderBottomLeftRadius: '12px'
        }}>
          <h3 style={{ marginTop: 0, color: currentTheme.text, marginBottom: '20px' }}>
            Animate: "{wordToAnimate.word}"
          </h3>

          {/* Animation Type Selection */}
          <div style={{ marginBottom: '20px' }}>
            {animationTypes.map(({ category, options }) => (
              <div key={category} style={{ marginBottom: '20px' }}>
                <label style={{ color: currentTheme.text, display: 'block', marginBottom: '10px', fontWeight: 'bold', fontSize: '16px' }}>
                  {category} Animations
                </label>
                <div style={{ display: 'grid', gap: '8px' }}>
                  {options.map(({ value, label, description }) => (
                    <label key={value} style={{
                      display: 'flex',
                      alignItems: 'center',
                      padding: '10px',
                      background: tempAnimation.type === value ? currentTheme.highlight + '20' : currentTheme.input,
                      border: `1px solid ${tempAnimation.type === value ? currentTheme.highlight : currentTheme.border}`,
                      borderRadius: '6px',
                      cursor: 'pointer',
                      transition: 'all 0.2s ease'
                    }}>
                      <input
                        type="radio"
                        name="animationType"
                        value={value}
                        checked={tempAnimation.type === value}
                        onChange={(e) => setTempAnimation(prev => ({ ...prev, type: e.target.value }))}
                        style={{ marginRight: '10px' }}
                      />
                      <div>
                        <div style={{ color: currentTheme.text, fontWeight: 'bold' }}>{label}</div>
                        <div style={{ color: currentTheme.text, opacity: 0.7, fontSize: '12px' }}>{description}</div>
                      </div>
                    </label>
                  ))}
                </div>
              </div>
            ))}
          </div>

          {/* Animation Controls */}
          {tempAnimation.type !== 'none' && (
            <div style={{ marginBottom: '20px' }}>
              <div style={{ display: 'grid', gap: '15px' }}>
                <div>
                  <label style={{ color: currentTheme.text, display: 'block', marginBottom: '5px' }}>
                    Duration: {tempAnimation.duration}s
                  </label>
                  <input
                    type="range"
                    min="0.3"
                    max="3.0"
                    step="0.1"
                    value={tempAnimation.duration}
                    onChange={(e) => setTempAnimation(prev => ({ ...prev, duration: parseFloat(e.target.value) }))}
                    style={{ width: '100%' }}
                  />
                </div>
                <div>
                  <label style={{ color: currentTheme.text, display: 'block', marginBottom: '5px' }}>
                    Delay: {tempAnimation.delay}s
                  </label>
                  <input
                    type="range"
                    min="0"
                    max="2.0"
                    step="0.1"
                    value={tempAnimation.delay}
                    onChange={(e) => setTempAnimation(prev => ({ ...prev, delay: parseFloat(e.target.value) }))}
                    style={{ width: '100%' }}
                  />
                </div>
              </div>
            </div>
          )}

          {/* Action Buttons */}
          <div style={{ display: 'flex', justifyContent: 'space-between', gap: '10px', marginTop: '20px' }}>
            <button
              onClick={cancelAnimationEdit}
              style={{
                padding: '10px 16px',
                background: 'transparent',
                color: currentTheme.text,
                border: `1px solid ${currentTheme.border}`,
                borderRadius: '6px',
                cursor: 'pointer',
                transition: 'background 0.2s ease'
              }}
              onMouseEnter={e => e.currentTarget.style.background = 'rgba(255,255,255,0.1)'}
              onMouseLeave={e => e.currentTarget.style.background = 'transparent'}
            >
              Cancel
            </button>

            {tempAnimation.type !== 'none' && (
              <button
                onClick={previewAnimation}
                style={{
                  padding: '10px 16px',
                  background: currentTheme.input,
                  color: currentTheme.text,
                  border: `1px solid ${currentTheme.border}`,
                  borderRadius: '6px',
                  cursor: 'pointer',
                  transition: 'background 0.2s ease'
                }}
                onMouseEnter={e => e.currentTarget.style.background = currentTheme.border}
                onMouseLeave={e => e.currentTarget.style.background = currentTheme.input}
              >
                Preview
              </button>
            )}

            <button
              onClick={saveAnimation}
              style={{
                padding: '10px 16px',
                background: currentTheme.button,
                color: currentTheme.buttonText,
                border: 'none',
                borderRadius: '6px',
                cursor: 'pointer',
                transition: 'background 0.2s ease'
              }}
              onMouseEnter={e => e.currentTarget.style.background = currentTheme.buttonHover}
              onMouseLeave={e => e.currentTarget.style.background = currentTheme.button}
            >
              Save Animation
            </button>
          </div>
        </div>
      </div>
    );
  };

  // Calculate background with natural color progression
  const calculatedBackground = globalAnimations.sentimentBackground 
    ? (() => {
        const score = displaySentimentScore;
        const intensity = sentimentIntensity;
        
        // Natural color progression system
        if (Math.abs(score) < 0.1) {
          // Neutral state - soft warm neutral
          const neutralColor = 'rgba(245, 245, 240, 0.6)'; // Warm light gray
          return `linear-gradient(135deg, ${neutralColor} 0%, rgba(240, 238, 230, 0.4) 100%), ${currentTheme.background}`;
        }
        
        if (score > 0) {
          // Positive progression: neutral → yellow-green → forest green
          const progress = Math.min(Math.abs(score) / 6, 1); // Normalize over 6 points for gentler transition
          const adjustedProgress = progress * intensity;
          
          // Color journey: warm neutral → yellow-green → forest green
          let r, g, b;
          
          if (adjustedProgress < 0.5) {
            // First half: neutral → yellow-green
            const t = adjustedProgress * 2; // 0 to 1
            r = Math.round(245 - (95 * t));   // 245 → 150 (warm to yellow-green)
            g = Math.round(245 - (15 * t));   // 245 → 230 (maintain brightness)
            b = Math.round(240 - (140 * t));  // 240 → 100 (reduce blue)
          } else {
            // Second half: yellow-green → forest green
            const t = (adjustedProgress - 0.5) * 2; // 0 to 1
            r = Math.round(150 - (70 * t));   // 150 → 80 (deeper)
            g = Math.round(230 - (50 * t));   // 230 → 180 (richer green)
            b = Math.round(100 - (20 * t));   // 100 → 80 (deeper)
          }
          
          const overlayOpacity = 0.3 + (adjustedProgress * 0.4);
          const overlayColor = `rgba(${r}, ${g}, ${b}, ${overlayOpacity})`;
          const gradientEnd = `rgba(${r-10}, ${g+5}, ${b-5}, ${overlayOpacity * 0.8})`;
          
          return `linear-gradient(135deg, ${overlayColor} 0%, ${gradientEnd} 100%), ${currentTheme.background}`;
        } else {
          // Negative progression: neutral → orange → cooler red
          const progress = Math.min(Math.abs(score) / 6, 1); // Normalize over 6 points
          const adjustedProgress = progress * intensity;
          
          // Color journey: warm neutral → orange → cooler, more unsettling red
          let r, g, b;
          
          if (adjustedProgress < 0.5) {
            // First half: neutral → orange
            const t = adjustedProgress * 2; // 0 to 1
            r = Math.round(245 + (10 * t));   // 245 → 255 (increase warmth)
            g = Math.round(245 - (90 * t));   // 245 → 155 (toward orange)
            b = Math.round(240 - (160 * t));  // 240 → 80 (reduce blue significantly)
          } else {
            // Second half: orange → cooler, more negative red
            const t = (adjustedProgress - 0.5) * 2; // 0 to 1
            r = Math.round(255 - (25 * t));   // 255 → 230 (slightly less saturated)
            g = Math.round(155 - (105 * t));  // 155 → 50 (much less yellow/orange)
            b = Math.round(80 - (20 * t));    // 80 → 60 (keep some coolness)
          }
          
          const overlayOpacity = 0.25 + (adjustedProgress * 0.4);
          const overlayColor = `rgba(${r}, ${g}, ${b}, ${overlayOpacity})`;
          const gradientEnd = `rgba(${Math.max(r-15, 200)}, ${Math.max(g-15, 35)}, ${Math.max(b-10, 45)}, ${overlayOpacity * 0.8})`;
          
          return `linear-gradient(135deg, ${overlayColor} 0%, ${gradientEnd} 100%), ${currentTheme.background}`;
        }
      })()
    : currentTheme.background;

  // Debug logging for background changes (less frequent)
  if (globalAnimations.sentimentBackground && Math.abs(displaySentimentScore - sentimentScore) < 0.1) {
    console.log('Background calculation:', {
      targetScore: sentimentScore,
      displayScore: displaySentimentScore.toFixed(2),
      sentimentIntensity,
      opacity: displaySentimentScore > 0 
        ? Math.min(displaySentimentScore * 0.1, 0.8) * sentimentIntensity
        : Math.min(Math.abs(displaySentimentScore) * 0.1, 0.8) * sentimentIntensity,
      background: calculatedBackground
    });
  }

  // Main render
  return (
    <div
      className={globalAnimations.sentimentBackground && displaySentimentScore > 2 ? 'positive-sentiment-background' : ''}
      style={{
        background: calculatedBackground,
        color: currentTheme.text,
        fontFamily,
        minHeight: '100vh',
        display: 'flex',
        flexDirection: 'column',
        transition: 'background 1.0s ease, color 0.5s ease'
      }}
    >
      {renderHeader()}
      {mode === 'editor' && <ThemeSwitcher />}

      {/* Error message */}
      {analysisError && (
        <div style={{
          position: 'fixed',
          top: '60px',
          left: '50%',
          transform: 'translateX(-50%)',
          backgroundColor: 'rgba(200, 30, 30, 0.9)',
          padding: '10px 20px',
          borderRadius: '8px',
          zIndex: 1000,
          color: 'white',
          maxWidth: '80%',
          textAlign: 'center',
          boxShadow: '0 4px 15px rgba(0, 0, 0, 0.3)',
          animation: 'fadeIn 0.3s ease'
        }}>
          <p style={{ margin: 0 }}>{analysisError}</p>
          <button
            onClick={() => setAnalysisError(null)}
            style={{
              position: 'absolute',
              top: '5px',
              right: '5px',
              background: 'none',
              border: 'none',
              color: 'white',
              fontSize: '16px',
              cursor: 'pointer'
            }}
          >
            ✕
          </button>
        </div>
      )}

      {/* Render modals */}
      {renderSentimentEditingModal()}
      {renderWordEditingModal()}
      {renderAnimationEditorModal()}

      {/* Main content area */}
      <div
        ref={containerRef}
        style={{
          flex: 1,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: wordData.length === 0 ? 'center' : 'flex-start',
          padding: '60px 20px 120px 20px',
          scrollBehavior: 'smooth'
        }}
      >
        <div
          style={{
            width: '100%',
            maxWidth: '800px',
            margin: '0 auto',
            textAlign: mode === 'editor' ? 'left' : 'center'
          }}
        >
          {Object.entries(groupedBySentence).length === 0 ? (
            <div style={{
              padding: '40px 20px',
              opacity: 0.7,
              textAlign: 'center',
              background: currentTheme.panel,
              borderRadius: '12px',
              boxShadow: '0 4px 15px rgba(0,0,0,0.1)',
              animation: 'fadeIn 0.5s ease'
            }}>
              <div style={{ fontSize: '48px', marginBottom: '20px' }}>🎵</div>
              {mode === 'editor' ?
                'Upload a transcript file to begin editing' :
                'Switch to editor mode to upload a transcript'}
            </div>
          ) : (
            Object.entries(groupedBySentence).map(([i, sentenceWords]) => {
              if (!sentenceWords || sentenceWords.length === 0) return null;

              const sentenceIndex = parseInt(i);
              const isCurrentSentence = sentenceWords.some(w => w.wordIndex === highlightIndex);
              const sentimentInfo = sentimentData[sentenceIndex];
              const hasSentiment = !!sentimentInfo;

              return (
                <div
                  key={sentenceIndex}
                  ref={(el) => sentenceRefs.current[sentenceIndex] = el}
                  onClick={() => {
                    if (mode === 'editor' && hasSentiment) {
                      setEditingSentimentIndex(sentenceIndex);
                    }
                  }}
                  style={{
                    marginBottom: '1.5rem',
                    lineHeight: '1.5',
                    opacity: mode === 'player' ? (isCurrentSentence ? 1 : 0.5) : 1,
                    transition: 'opacity 0.3s ease, transform 0.3s ease, filter 0.3s ease',
                    textAlign: 'center',
                    display: 'block',
                    position: 'relative',
                    filter: mode === 'player' && !isCurrentSentence ? 'blur(1px)' : 'none',
                    transform: mode === 'player' && isCurrentSentence ? 'scale(1.05)' : 'scale(1)',
                    background: mode === 'editor' ? getSentimentColor(sentenceIndex) : 'transparent',
                    padding: '8px',
                    borderRadius: '8px',
                    cursor: mode === 'editor' && hasSentiment ? 'pointer' : 'default'
                  }}
                >
                  {/* Sentiment indicator for editor mode */}
                  {mode === 'editor' && hasSentiment && (
                    <div style={{
                      position: 'absolute',
                      top: '-10px',
                      right: '-10px',
                      background: currentTheme.panel,
                      borderRadius: '50%',
                      width: '24px',
                      height: '24px',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
                      cursor: 'pointer',
                      zIndex: 5
                    }}
                      onClick={(e) => {
                        e.stopPropagation();
                        setEditingSentimentIndex(sentenceIndex);
                      }}
                    >
                      {getSentimentEmoji(sentimentInfo.sentiment)}
                    </div>
                  )}

                  {mode === 'player' ? (
                    <div style={{ display: 'inline-block', textAlign: 'center' }}>
                      {sentenceWords.map((word, j) => {
                        const isActive = word.wordIndex <= highlightIndex;
                        const shouldAnimate = word.animation?.type !== 'none' && isActive;
                        const animationClass = shouldAnimate ? `word-animate-${word.animation.type}` : '';
                        
                        // Apply global audio effects
                        let dynamicStyle = {
                          fontSize: word.size,
                          color: isActive ? currentTheme.active : currentTheme.inactive,
                          fontWeight: isActive ? 'bold' : 'normal',
                          margin: '0 2px',
                          display: 'inline-block',
                          transition: word.animation?.type === 'none' ? 'color 0.05s ease, font-weight 0.05s ease' : 'none',
                          '--duration': shouldAnimate ? `${word.animation.duration}s` : '1.2s',
                          '--delay': shouldAnimate ? `${word.animation.delay}s` : '0s'
                        };

                        // No audio effects needed anymore - sentiment background handles global mood
                        
                        return (
                          <span
                            key={j}
                            className={animationClass}
                            style={dynamicStyle}
                          >
                            {word.word}{j < sentenceWords.length - 1 ? ' ' : ''}
                          </span>
                        );
                      })}
                    </div>
                  ) : (
                    // Editor mode with word-by-word editing
                    <div style={{ display: 'block', textAlign: 'left', width: '100%' }}>
                      {sentenceWords.map((w) => (
                        <span
                          key={w.wordIndex}
                          data-word-index={w.wordIndex}
                          onContextMenu={(e) => {
                            e.preventDefault();
                            if (mode === 'editor') {
                              openAnimationEditor(w.wordIndex);
                            }
                          }}
                          onClick={(e) => {
                            e.stopPropagation();
                            if (mode === 'editor') {
                              setEditingWordIndex(w.wordIndex);
                              setEditedWordText(w.word);
                            }
                          }}
                          style={{
                            fontSize: w.size,
                            color: w.color,
                            fontWeight: w.wordIndex === highlightIndex ? 'bold' : 'normal',
                            margin: '0 4px',
                            padding: '2px',
                            cursor: 'pointer',
                            display: 'inline-block',
                            transition: 'color 0.1s ease, font-weight 0.1s ease',
                            textDecoration: mode === 'editor' ? 'underline dotted' : 'none',
                            textDecorationColor: mode === 'editor' ? 'rgba(255,255,255,0.3)' : 'none',
                            background: w.animation?.type !== 'none' ? currentTheme.highlight + '20' : 'transparent',
                            borderRadius: w.animation?.type !== 'none' ? '3px' : '0'
                          }}
                          title={mode === 'editor' ? 'Left click: Edit text | Right click: Add animation' : ''}
                        >
                          {w.word}
                        </span>
                      ))}
                    </div>
                  )}
                </div>
              );
            })
          )}
        </div>
      </div>

      {/* Bottom controls */}
      <div
        style={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          gap: '15px',
          padding: '20px',
          width: '100%',
          background: currentTheme.panel,
          borderTop: `1px solid ${currentTheme.border}`
        }}
      >
        {audioUrl && (
          <audio
            ref={audioRef}
            controls
            src={audioUrl}
            style={{
              width: '100%',
              maxWidth: '600px',
              borderRadius: '8px',
              boxShadow: '0 4px 8px rgba(0,0,0,0.1)'
            }}
          />
        )}

        {mode === 'editor' && (
          <>
            <div style={{
              display: 'flex',
              flexWrap: 'wrap',
              justifyContent: 'center',
              gap: '10px',
              width: '100%',
              maxWidth: '600px'
            }}>
              <div style={{
                position: 'relative',
                overflow: 'hidden',
                padding: '8px 16px',
                background: currentTheme.button,
                color: currentTheme.buttonText,
                borderRadius: '8px',
                cursor: 'pointer',
                display: 'inline-block',
                textAlign: 'center',
                boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
                transition: 'all 0.2s ease'
              }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.background = currentTheme.buttonHover;
                  e.currentTarget.style.transform = 'translateY(-2px)';
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.background = currentTheme.button;
                  e.currentTarget.style.transform = 'translateY(0)';
                }}>
                Upload Audio
                <input
                  type="file"
                  accept="audio/*"
                  onChange={handleAudioUpload}
                  style={{
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    opacity: 0,
                    width: '100%',
                    height: '100%',
                    cursor: 'pointer'
                  }}
                />
              </div>

              <div style={{
                position: 'relative',
                overflow: 'hidden',
                padding: '8px 16px',
                background: currentTheme.button,
                color: currentTheme.buttonText,
                borderRadius: '8px',
                cursor: 'pointer',
                display: 'inline-block',
                textAlign: 'center',
                boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
                transition: 'all 0.2s ease'
              }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.background = currentTheme.buttonHover;
                  e.currentTarget.style.transform = 'translateY(-2px)';
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.background = currentTheme.button;
                  e.currentTarget.style.transform = 'translateY(0)';
                }}>
                Upload Transcript
                <input
                  type="file"
                  accept=".txt"
                  onChange={handleTranscriptUpload}
                  style={{
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    opacity: 0,
                    width: '100%',
                    height: '100%',
                    cursor: 'pointer'
                  }}
                />
              </div>
            </div>

            {/* Controls */}
            {renderEditorControls()}

            {/* Sentiment analysis legend */}
            {Object.keys(sentimentData).length > 0 && (
              <div style={{
                display: 'flex',
                gap: '15px',
                marginTop: '15px',
                padding: '15px',
                background: currentTheme.modal,
                borderRadius: '8px',
                flexWrap: 'wrap',
                justifyContent: 'center',
                boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
                animation: 'fadeIn 0.5s ease'
              }}>
                {Object.entries(currentTheme.sentiments).map(([sentiment, color]) => (
                  <div key={sentiment} style={{ display: 'flex', alignItems: 'center', gap: '5px' }}>
                    <span style={{
                      display: 'inline-block',
                      width: '15px',
                      height: '15px',
                      background: color,
                      borderRadius: '3px'
                    }}></span>
                    <span>{sentiment.charAt(0).toUpperCase() + sentiment.slice(1)} {getSentimentEmoji(sentiment)}</span>
                  </div>
                ))}
                <div style={{ width: '100%', textAlign: 'center', marginTop: '5px', fontSize: '14px', opacity: 0.8 }}>
                  Click on any highlighted sentence to edit its sentiment
                </div>
                <div style={{ width: '100%', textAlign: 'center', fontSize: '14px', opacity: 0.8 }}>
                  Click on any word to edit it directly
                </div>
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
}